
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">dcard-backend-2024/pkg/controller/ad_controller.go (76.2%)</option>
				
				<option value="file1">dcard-backend-2024/pkg/dispatcher/request_multiplexer.go (60.0%)</option>
				
				<option value="file2">dcard-backend-2024/pkg/dispatcher/type.go (76.5%)</option>
				
				<option value="file3">dcard-backend-2024/pkg/inmem/index.go (70.4%)</option>
				
				<option value="file4">dcard-backend-2024/pkg/inmem/store.go (77.3%)</option>
				
				<option value="file5">dcard-backend-2024/pkg/service/ad.go (54.0%)</option>
				
				<option value="file6">dcard-backend-2024/pkg/service/task.go (0.0%)</option>
				
				<option value="file7">dcard-backend-2024/pkg/syncmap/sync_map.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "dcard-backend-2024/pkg/inmem"
        "dcard-backend-2024/pkg/model"
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"
)

type AdController struct {
        adService model.AdService
}

func NewAdController(adService model.AdService) *AdController <span class="cov8" title="1">{
        return &amp;AdController{
                adService: adService,
        }
}</span>

// GetAd godoc
// @Summary Get an ad by ID
// @Description Retrieves an ad by ID
// @Tags Ad
// @Accept json
// @Produce json
// @Param offset query int false "Offset for pagination"
// @Param limit query int false "Limit for pagination"
// @Param age query int false "Age"
// @Param gender query string false "Gender"
// @Param country query string false "Country"
// @Param platform query string false "Platform"
// @Success 200 {object} model.GetAdsPageResponse
// @Failure 404 {object} model.Response
// @Failure 500 {object} model.Response
// @Router /api/v1/ad [get]
func (ac *AdController) GetAd(c *gin.Context) <span class="cov8" title="1">{
        var req model.GetAdRequest
        if err := c.BindQuery(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, model.Response{Msg: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">ads, total, err := ac.adService.GetAds(c, &amp;req)
        switch </span>{
        case errors.Is(err, inmem.ErrNoAdsFound):<span class="cov0" title="0">
                c.JSON(http.StatusNotFound, model.Response{Msg: err.Error()})
                return</span>
        case err != nil:<span class="cov0" title="0">
                c.JSON(http.StatusInternalServerError, model.Response{Msg: err.Error()})
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, model.GetAdsPageResponse{Ads: ads, Total: total})</span>
}

// CreateAd godoc
// @Summary Create an ad
// @Description Create an ad
// @Tags Ad
// @Accept json
// @Produce json
// @Param ad body model.CreateAdRequest true "Ad object"
// @Success 201 {object} model.CreateAdResponse
// @Failure 400 {object} model.Response
// @Failure 500 {object} model.Response
// @Router /api/v1/ad [post]
func (ac *AdController) CreateAd(c *gin.Context) <span class="cov8" title="1">{
        var ad model.CreateAdRequest
        if err := c.BindJSON(&amp;ad); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, model.Response{Msg: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">adID, err := ac.adService.CreateAd(c,
                &amp;model.Ad{
                        Title:    ad.Title,
                        Content:  ad.Content,
                        StartAt:  ad.StartAt,
                        EndAt:    ad.EndAt,
                        AgeStart: ad.AgeStart,
                        AgeEnd:   ad.AgeEnd,
                        Gender:   ad.Gender,
                        Country:  ad.Country,
                        Platform: ad.Platform,
                },
        )
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, model.Response{Msg: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, model.Response{Msg: "Ad created", Data: adID})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package dispatcher

import (
        "dcard-backend-2024/pkg/model"
        "dcard-backend-2024/pkg/syncmap"
        "log"
        "sync/atomic"
        "time"
)

type Dispatcher struct {
        Running      atomic.Bool
        RequestChan  chan interface{}
        ResponseChan *syncmap.Map
        Store        model.InMemoryStore
}

func (r *Dispatcher) IsRunning() bool <span class="cov8" title="1">{
        return r.Running.Load()
}</span>

func NewDispatcher(store model.InMemoryStore) *Dispatcher <span class="cov8" title="1">{
        return &amp;Dispatcher{
                RequestChan:  make(chan interface{}),
                ResponseChan: &amp;syncmap.Map{},
                Store:        store,
        }
}</span>

func (r *Dispatcher) handleCreateBatchAdRequest(req *CreateBatchAdRequest) <span class="cov8" title="1">{
        // err := r.Store.CreateBatchAds(req.Ads)
        for _, ad := range req.Ads </span><span class="cov8" title="1">{
                if time.Now().After(ad.StartAt.T()) </span><span class="cov8" title="1">{
                        _, err := r.Store.CreateAd(ad)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to create ad %s: %v", ad.ID, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("ad %s is scheduled to start at %s", ad.ID, ad.StartAt.T())
                        time.AfterFunc(time.Until(ad.StartAt.T()), func() </span><span class="cov0" title="0">{
                                _, err := r.Store.CreateAd(ad)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("failed to create ad %s: %v", ad.ID, err)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("scheduled ad %s is created", ad.ID)
                                }</span>
                        })
                }
        }

        // use sync map to store the response channel
        <span class="cov8" title="1">if r.ResponseChan.Exists(req.RequestID) </span><span class="cov8" title="1">{
                r.ResponseChan.Load(req.RequestID) &lt;- &amp;CreateAdResponse{
                        Response: Response{RequestID: req.RequestID},
                        Err:      nil,
                }
        }</span>
}

func (r *Dispatcher) handleCreateAdRequest(req *CreateAdRequest) <span class="cov8" title="1">{
        if time.Now().After(req.Ad.StartAt.T()) </span><span class="cov8" title="1">{
                _, err := r.Store.CreateAd(req.Ad)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to create ad %s: %v", req.Ad.ID, err)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("ad %s is scheduled to start at %s", req.Ad.ID, req.Ad.StartAt.T())
                time.AfterFunc(time.Until(req.Ad.StartAt.T()), func() </span><span class="cov0" title="0">{
                        _, err := r.Store.CreateAd(req.Ad)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to create ad %s: %v", req.Ad.ID, err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("scheduled ad %s is created", req.Ad.ID)
                        }</span>
                })
        }

        <span class="cov8" title="1">if r.ResponseChan.Exists(req.RequestID) </span><span class="cov8" title="1">{
                r.ResponseChan.Load(req.RequestID) &lt;- &amp;CreateAdResponse{
                        Response: Response{RequestID: req.RequestID},
                        AdID:     req.Ad.ID.String(),
                        Err:      nil,
                }
        }</span>
}

func (r *Dispatcher) handleGetAdRequest(req *GetAdRequest) <span class="cov8" title="1">{
        ads, total, err := r.Store.GetAds(req.GetAdRequest)

        if r.ResponseChan.Exists(req.RequestID) </span><span class="cov8" title="1">{
                r.ResponseChan.Load(req.RequestID) &lt;- &amp;GetAdResponse{
                        Response: Response{RequestID: req.RequestID},
                        Ads:      ads,
                        Total:    total,
                        Err:      err,
                }
        }</span>
}

func (r *Dispatcher) handleDeleteAdRequest(req *DeleteAdRequest) <span class="cov0" title="0">{
        _ = r.Store.DeleteAd(req.AdID)

        // if r.ResponseChan.Exists(req.RequestID) {
        //         r.ResponseChan.Load(req.RequestID) &lt;- &amp;DeleteAdResponse{
        //                 Response: Response{RequestID: req.RequestID},
        //                 Err:      err,
        //         }
        // }
}</span>

func (r *Dispatcher) Start() <span class="cov8" title="1">{
        r.Running.Store(true)
        log.Println("Dispatcher started")
        for </span><span class="cov8" title="1">{
                select </span>{
                case req := &lt;-r.RequestChan:<span class="cov8" title="1">
                        switch req.(type) </span>{
                        case *CreateBatchAdRequest:<span class="cov8" title="1">
                                r.handleCreateBatchAdRequest(req.(*CreateBatchAdRequest))</span>
                        case *CreateAdRequest:<span class="cov8" title="1">
                                // the create ad request is from the redis stream
                                r.handleCreateAdRequest(req.(*CreateAdRequest))</span>
                        case *GetAdRequest:<span class="cov8" title="1">
                                go r.handleGetAdRequest(req.(*GetAdRequest))</span>
                        case *DeleteAdRequest:<span class="cov0" title="0">
                                r.handleDeleteAdRequest(req.(*DeleteAdRequest))</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dispatcher

import (
        "dcard-backend-2024/pkg/model"
        "encoding/json"
)

type IRequest interface {
        RequestUID() string
}

type Request struct {
        IRequest
        RequestID string `json:"request_id"`
}

func (r *Request) RequestUID() string <span class="cov8" title="1">{
        return r.RequestID
}</span>

type IResult interface {
        Error() error
}

type Response struct {
        RequestID string `json:"request_id"`
}

type CreateAdRequest struct {
        Request
        *model.Ad
}

type CreateBatchAdRequest struct {
        Request
        Ads []*model.Ad
}

func (r *CreateAdRequest) ToMap() (map[string]interface{}, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var result map[string]interface{}
        if err := json.Unmarshal(jsonData, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (r *CreateAdRequest) FromMap(m map[string]interface{}) error <span class="cov8" title="1">{
        jsonData, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(jsonData, r); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type CreateAdResponse struct {
        IResult
        Response
        AdID string
        Err  error
}

func (r *CreateAdResponse) Error() error <span class="cov8" title="1">{
        return r.Err
}</span>

type GetAdRequest struct {
        Request
        *model.GetAdRequest
}

type GetAdResponse struct {
        IResult
        Response
        Ads   []*model.Ad
        Total int
        Err   error
}

func (r *GetAdResponse) Error() error <span class="cov8" title="1">{
        return r.Err
}</span>

type DeleteAdRequest struct {
        Request
        AdID string
}

type DeleteAdResponse struct {
        IResult
        Response
        Err error
}

func (r *DeleteAdResponse) Error() error <span class="cov0" title="0">{
        return r.Err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package inmem

import (
        "dcard-backend-2024/pkg/model"
        "fmt"
        "log"
        "sync"

        cmap "github.com/orcaman/concurrent-map/v2"
        "github.com/wangjia184/sortedset"
)

type IndexNode interface {
        AddAd(ad *model.Ad)
        GetAd(req *model.GetAdRequest) ([]*model.Ad, error)
        DeleteAd(ad *model.Ad)
}

type FieldStringer struct {
        Value interface{}
}

func (f FieldStringer) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v", f.Value)
}</span>

func (g *IndexInternalNode) AddAd(ad *model.Ad) <span class="cov8" title="1">{
        values, err := ad.GetValueByKey(g.Key)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("AddAd: Error getting value by key \"%s\": %s\n", g.Key, err)
                return
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup

        for _, v := range values </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(v interface{}) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        field := FieldStringer{Value: v}

                        child, exists := g.Children.Get(field)
                        if !exists </span><span class="cov8" title="1">{
                                nextKey := model.Ad{}.GetNextIndexKey(g.Key)
                                if nextKey == "" </span><span class="cov8" title="1">{
                                        child = NewIndexLeafNode()
                                }</span> else<span class="cov8" title="1"> {
                                        child = NewIndexInternalNode(nextKey)
                                }</span>
                                <span class="cov8" title="1">g.Children.Set(field, child)</span>
                        }

                        <span class="cov8" title="1">child.AddAd(ad)</span>
                }(v)
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

// GetAd implements IndexNode.
func (g *IndexInternalNode) GetAd(req *model.GetAdRequest) ([]*model.Ad, error) <span class="cov8" title="1">{
        values, err := req.GetValueByKey(g.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GetAd: Error getting value by key \"%s\": %s", g.Key, err)
        }</span>

        <span class="cov8" title="1">Field := FieldStringer{Value: values}
        child, exists := g.Children.Get(Field)
        if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">ads, err := child.GetAd(req)
        return ads, nil</span>
}

// DeleteAd implements IndexNode.
func (g *IndexInternalNode) DeleteAd(ad *model.Ad) <span class="cov0" title="0">{
        values, err := ad.GetValueByKey(g.Key)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting value by key \"%s\": %s\n", g.Key, err)
                return
        }</span>

        <span class="cov0" title="0">for _, v := range values </span><span class="cov0" title="0">{
                field := FieldStringer{Value: v}
                child, exists := g.Children.Get(field)
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">child.DeleteAd(ad)</span>
        }
}

type IndexInternalNode struct {
        Key      string                                       // The key this node indexes on, e.g., "country", "age"
        Children cmap.ConcurrentMap[FieldStringer, IndexNode] // The children of this node
}

func NewIndexInternalNode(key string) IndexNode <span class="cov8" title="1">{
        return &amp;IndexInternalNode{
                Key:      key,
                Children: cmap.NewStringer[FieldStringer, IndexNode](),
        }
}</span>

type IndexLeafNode struct {
        mu  sync.RWMutex
        Ads *sortedset.SortedSet // map[string]*model.Ad
}

func (g *IndexLeafNode) AddAd(ad *model.Ad) <span class="cov8" title="1">{
        g.mu.Lock()
        defer g.mu.Unlock()
        g.Ads.AddOrUpdate(ad.ID.String(), sortedset.SCORE(ad.CreatedAt.T().Unix()), ad)
}</span>

// GetAd implements IndexNode.
func (g *IndexLeafNode) GetAd(req *model.GetAdRequest) ([]*model.Ad, error) <span class="cov8" title="1">{
        g.mu.RLock()
        defer g.mu.RUnlock()
        ad := g.Ads.GetByRankRange(req.Offset, req.Offset+req.Limit, false)
        ret := make([]*model.Ad, len(ad))
        for i, a := range ad </span><span class="cov8" title="1">{
                ret[i] = a.Value.(*model.Ad)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

// DeleteAd implements IndexNode.
func (g *IndexLeafNode) DeleteAd(ad *model.Ad) <span class="cov0" title="0">{
        g.mu.Lock()
        defer g.mu.Unlock()
        g.Ads.Remove(ad.ID.String())
}</span>

func NewIndexLeafNode() IndexNode <span class="cov8" title="1">{
        return &amp;IndexLeafNode{
                Ads: sortedset.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package inmem

import (
        "dcard-backend-2024/pkg/model"
        "fmt"
        "sync"
)

var (
        // ErrNoAdsFound is returned when the ad is not found in the store, 404
        ErrNoAdsFound error = fmt.Errorf("no ads found")
        // ErrOffsetOutOfRange is returned when the offset is out of range, 404
        ErrOffsetOutOfRange error = fmt.Errorf("offset is out of range")
        // ErrInvalidVersion is returned when the version is invalid, inconsistent with the store
        ErrInvalidVersion error = fmt.Errorf("invalid version")
)

// InMemoryStoreImpl is an in-memory ad store implementation
type InMemoryStoreImpl struct {
        // ads maps ad IDs to ads
        ads         map[string]*model.Ad
        adIndexRoot IndexNode
        mutex       sync.RWMutex
}

func NewInMemoryStore() model.InMemoryStore <span class="cov8" title="1">{
        return &amp;InMemoryStoreImpl{
                ads:         make(map[string]*model.Ad),
                adIndexRoot: NewIndexInternalNode(model.Ad{}.GetNextIndexKey("")),
                mutex:       sync.RWMutex{},
        }
}</span>

// CreateBatchAds creates a batch of ads in the store
// (only used in the snapshot restore)
func (s *InMemoryStoreImpl) CreateBatchAds(ads []*model.Ad) (err error) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        for _, ad := range ads </span><span class="cov8" title="1">{
                s.ads[ad.ID.String()] = ad
                s.adIndexRoot.AddAd(ad)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *InMemoryStoreImpl) CreateAd(ad *model.Ad) (string, error) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        s.ads[ad.ID.String()] = ad
        s.adIndexRoot.AddAd(ad)
        return ad.ID.String(), nil
}</span>

func (s *InMemoryStoreImpl) GetAds(req *model.GetAdRequest) (ads []*model.Ad, count int, err error) <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        ads, err = s.adIndexRoot.GetAd(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">return ads, len(ads), nil</span>
}

// DeleteAd implements model.InMemoryStore.
func (s *InMemoryStoreImpl) DeleteAd(adID string) error <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()
        s.adIndexRoot.DeleteAd(s.ads[adID])
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "context"
        "database/sql"
        "dcard-backend-2024/pkg/dispatcher"
        "dcard-backend-2024/pkg/model"
        "encoding/json"
        "fmt"
        "log"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/bsm/redislock"
        "github.com/cenkalti/backoff/v4"
        "github.com/google/uuid"
        "github.com/hibiken/asynq"
        "github.com/redis/go-redis/v9"
        "gorm.io/gorm"
)

var (
        ErrTimeout = fmt.Errorf("timeout")
        ErrUnknown = fmt.Errorf("unknown error")
)

type AdService struct {
        shutdown    atomic.Bool
        dispatcher  *dispatcher.Dispatcher
        db          *gorm.DB
        redis       *redis.Client
        locker      *redislock.Client
        asynqClient *asynq.Client
        lockKey     string
        // adStream is the redis stream name for the ad
        adStream   string
        mu         sync.Mutex
        wg         sync.WaitGroup
        onShutdown []func()
        Version    int // Version is the latest version of the ad
}

// DeleteAd implements model.AdService.
func (a *AdService) DeleteAd(ctx context.Context, adID string) error <span class="cov0" title="0">{
        ctx = context.Background()
        // RedisLock Lock Key: lock:ad
        lock, err := a.locker.Obtain(ctx, a.lockKey, 100*time.Millisecond, &amp;redislock.Options{
                RetryStrategy: redislock.LimitRetry(redislock.ExponentialBackoff(1*time.Millisecond, 5*time.Millisecond), 10),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error obtaining lock: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // Release Lock
                err := lock.Release(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error releasing lock: %v", err)
                }</span>
        }()
        // Begin Transaction
        // UPDATE ads SET is_active = false AND version = `SELECT MAX(version) FROM ads` + 1 WHERE id = adID
        // DELETE FROM ads WHERE version &lt; `SELECT MAX(version) FROM ads` AND is_active = false
        // Commit Transaction
        <span class="cov0" title="0">txn := a.db.Begin()
        if err = txn.Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var maxVersion int
        if err = txn.Raw("SELECT COALESCE(MAX(version), 0) FROM ads").Scan(&amp;maxVersion).Error; err != nil </span><span class="cov0" title="0">{
                txn.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">maxVersion++
        if err = txn.Model(&amp;model.Ad{}).Where("id = ?", adID).
                Update("is_active", false).
                Update("version", maxVersion).Error; err != nil </span><span class="cov0" title="0">{
                txn.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if err = txn.Delete(&amp;model.Ad{}, "version &lt; ? AND is_active = false", maxVersion).Error; err != nil </span><span class="cov0" title="0">{
                txn.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">err = txn.Commit().Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">adReqMapStr, err := json.Marshal(dispatcher.DeleteAdRequest{AdID: adID})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error marshalling ad request: %v", err)
                return err
        }</span>
        // Publish to Redis Stream
        // XADD ad 0-`SELECT MAX(version) FROM ads` {"ad": "adReqJsonStr"}
        <span class="cov0" title="0">_, err = a.redis.XAdd(ctx, &amp;redis.XAddArgs{
                Stream:     a.adStream,
                NoMkStream: false,
                Approx:     false,
                MaxLen:     100000,
                Values: []interface{}{
                        "ad", string(adReqMapStr),
                        "type", "delete",
                },
                ID: fmt.Sprintf("0-%d", maxVersion),
        }).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error publishing to redis: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Shutdown implements model.AdService.
func (a *AdService) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        a.shutdown.Store(true)
        done := make(chan struct{})
        a.mu.Lock()
        for _, f := range a.onShutdown </span><span class="cov8" title="1">{
                go f()
        }</span>
        <span class="cov8" title="1">a.mu.Unlock()
        go func() </span><span class="cov8" title="1">{
                a.wg.Wait()
                close(done)
        }</span>()
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// Run implements model.AdService.
func (a *AdService) Run() error <span class="cov8" title="1">{
        go a.dispatcher.Start() // Start the dispatcher
        stopCh := make(chan struct{}, 1)

        a.wg.Add(1)
        defer a.wg.Done()

        a.registerOnShutdown(func() </span><span class="cov8" title="1">{
                close(stopCh)
        }</span>)

        <span class="cov8" title="1">operation := func() error </span><span class="cov8" title="1">{
                err := a.Restore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error restoring: %v", err)
                        return err
                }</span>
                <span class="cov8" title="1">err = a.Subscribe()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error subscribing: %v", err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">maxRetry := 5
        operationBackoff := backoff.WithMaxRetries(backoff.NewExponentialBackOff(), uint64(maxRetry))

        for a.shutdown.Load() == false </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-stopCh:<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov8" title="1">
                        err := backoff.Retry(operation, operationBackoff)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("error running: %v", err)
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Restore restores the latest version of an ad from the database.
// It returns the version number of the restored ad and any error encountered.
// The error could be ErrRecordNotFound if no ad is found or a DB connection error.
func (a *AdService) Restore() (err error) <span class="cov8" title="1">{
        txn := a.db.Begin(&amp;sql.TxOptions{Isolation: sql.LevelRepeatableRead})
        err = txn.Raw("SELECT COALESCE(MAX(version), 0) FROM ads").Scan(&amp;a.Version).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var ads []*model.Ad
        err = txn.Where("is_active = ?", true).Find(&amp;ads).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = txn.Commit().Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">requestID := uuid.New().String()
        a.dispatcher.ResponseChan.Store(requestID, make(chan interface{}, 1))
        defer a.dispatcher.ResponseChan.Delete(requestID)
        a.dispatcher.RequestChan &lt;- &amp;dispatcher.CreateBatchAdRequest{
                Request: dispatcher.Request{RequestID: requestID},
                Ads:     ads,
        }

        select </span>{
        case resp := &lt;-a.dispatcher.ResponseChan.Load(requestID):<span class="cov8" title="1">
                if resp, ok := resp.(*dispatcher.CreateAdResponse); ok </span><span class="cov8" title="1">{
                        if resp.Err == nil </span><span class="cov8" title="1">{
                                log.Printf("Restored version: %d successfully\n", a.Version)
                        }</span>
                        <span class="cov8" title="1">return resp.Err</span>
                }
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                return ErrTimeout</span>
        }
        <span class="cov0" title="0">return ErrUnknown</span>
}

// Subscribe implements model.AdService.
func (a *AdService) Subscribe() error <span class="cov8" title="1">{
        log.Printf("subscribing to redis stream with offset: %d", a.Version)
        ctx := context.Background()
        lastID := fmt.Sprintf("0-%d", a.Version) // Assuming offset can be mapped directly to Redis Stream IDs
        stopCh := make(chan struct{}, 1)

        a.wg.Add(1)
        defer a.wg.Done()

        a.registerOnShutdown(func() </span><span class="cov8" title="1">{
                close(stopCh)
        }</span>)

        <span class="cov8" title="1">for a.shutdown.Load() == false </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-stopCh:<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov8" title="1">
                        // Reading from the stream
                        xReadArgs := &amp;redis.XReadArgs{
                                Streams: []string{a.adStream, lastID},
                                Block:   3 * time.Second,
                                Count:   10,
                        }
                        msgs, err := a.redis.XRead(ctx, xReadArgs).Result()
                        if err != nil </span><span class="cov8" title="1">{
                                // log.Printf("error reading from redis: %v", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, msg := range msgs </span><span class="cov0" title="0">{
                                for _, m := range msg.Messages </span><span class="cov0" title="0">{
                                        log.Printf("received message: %v\n", m)
                                        streamVersion, _ := strconv.ParseInt(strings.Split(m.ID, "-")[1], 10, 64)
                                        if a.Version &lt; int(streamVersion) </span><span class="cov0" title="0">{
                                                a.Version = int(streamVersion)
                                                lastID = m.ID
                                        }</span> else<span class="cov0" title="0"> {
                                                // our version is the same or higher than the stream version
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">switch m.Values["type"].(string) </span>{
                                        case "create":<span class="cov0" title="0">
                                                payload := &amp;dispatcher.CreateAdRequest{}
                                                json.Unmarshal([]byte(m.Values["ad"].(string)), payload)
                                                a.dispatcher.RequestChan &lt;- payload</span>
                                        case "delete":<span class="cov0" title="0">
                                                payload := &amp;dispatcher.DeleteAdRequest{}
                                                json.Unmarshal([]byte(m.Values["ad"].(string)), payload)
                                                a.dispatcher.RequestChan &lt;- payload</span>
                                        default:<span class="cov0" title="0">
                                                log.Printf("unknown message type: %s", m.Values["type"].(string))</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (a *AdService) registerOnShutdown(f func()) <span class="cov8" title="1">{
        a.mu.Lock()
        a.onShutdown = append(a.onShutdown, f)
        a.mu.Unlock()
}</span>

func (a *AdService) onShutdownNum() int <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        return len(a.onShutdown)
}</span>

// storeAndPublishWithLock
//
// 1. locks the lockKey
//
// 2. stores the ad in the database, and set the version of the new ad to `SELECT MAX(version) FROM ad“ + 1
//
// 3. publishes the ad into redis stream. (ensure the message sequence number is the same as the ad's version)
//
// 4. releases the lock
func (a *AdService) storeAndPublishWithLock(ctx context.Context, ad *model.Ad, requestID string) (err error) <span class="cov8" title="1">{
        ctx = context.Background()
        lock, err := a.locker.Obtain(ctx, a.lockKey, 100*time.Millisecond, &amp;redislock.Options{
                RetryStrategy: redislock.LimitRetry(redislock.ExponentialBackoff(1*time.Millisecond, 5*time.Millisecond), 10),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error obtaining lock: %v", err)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err := lock.Release(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("error releasing lock: %v", err)
                }</span>
        }()
        <span class="cov8" title="1">txn := a.db.Begin()
        if err = txn.Error; err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var maxVersion int
        if err = txn.Raw("SELECT COALESCE(MAX(version), 0) FROM ads").Scan(&amp;maxVersion).Error; err != nil </span><span class="cov0" title="0">{
                txn.Rollback()
                return
        }</span>
        <span class="cov8" title="1">ad.Version = maxVersion + 1
        if err = txn.Create(ad).Error; err != nil </span><span class="cov0" title="0">{
                txn.Rollback()
                return
        }</span>
        <span class="cov8" title="1">err = txn.Commit().Error
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">adReq := &amp;dispatcher.CreateAdRequest{
                Request: dispatcher.Request{RequestID: requestID},
                Ad:      ad,
        }
        // adReqMap, err := adReq.ToMap()
        adReqMapStr, err := json.Marshal(adReq)
        // return requestID, nil
        // log.Printf("adReqJsonStr: %s", adReqJsonStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error marshalling ad request: %v", err)
                return
        }</span>
        <span class="cov8" title="1">_, err = a.redis.XAdd(ctx, &amp;redis.XAddArgs{
                Stream:     a.adStream,
                NoMkStream: false,
                Approx:     false,
                MaxLen:     100000,
                Values: []interface{}{
                        "ad", string(adReqMapStr),
                        "type", "create",
                },
                ID: fmt.Sprintf("0-%d", ad.Version),
        }).Result()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("error publishing to redis: %v", err)
                return
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CreateAd implements model.AdService.
func (a *AdService) CreateAd(ctx context.Context, ad *model.Ad) (adID string, err error) <span class="cov8" title="1">{
        a.wg.Add(1)
        defer a.wg.Done()
        requestID := uuid.New().String()
        a.dispatcher.ResponseChan.Store(requestID, make(chan interface{}, 1))
        defer a.dispatcher.ResponseChan.Delete(requestID)
        err = a.storeAndPublishWithLock(ctx, ad, requestID)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = a.registerAdDeleteTask(ad)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">select </span>{
        case resp := &lt;-a.dispatcher.ResponseChan.Load(requestID):<span class="cov0" title="0">
                if resp, ok := resp.(*dispatcher.CreateAdResponse); ok </span><span class="cov0" title="0">{
                        return resp.AdID, resp.Err
                }</span>
        case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                return "", ErrTimeout</span>
        }

        <span class="cov0" title="0">return "", ErrUnknown</span>
}

func (a *AdService) registerAdDeleteTask(ad *model.Ad) error <span class="cov0" title="0">{
        payload := &amp;model.AsynqDeletePayload{AdID: ad.ID.String()}
        task, err := payload.ToTask()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">taskID := fmt.Sprintf("%s-%s", payload.TypeName(), ad.ID.String())
        processTime := ad.EndAt.T()
        _, err = a.asynqClient.Enqueue(
                task,
                asynq.ProcessAt(processTime),
                asynq.TaskID(taskID),
        )
        return err</span>
}

// GetAds implements model.AdService.
func (a *AdService) GetAds(ctx context.Context, req *model.GetAdRequest) ([]*model.Ad, int, error) <span class="cov8" title="1">{
        a.wg.Add(1)
        defer a.wg.Done()

        requestID := uuid.New().String()

        a.dispatcher.ResponseChan.Store(requestID, make(chan interface{}, 1))
        defer a.dispatcher.ResponseChan.Delete(requestID)

        a.dispatcher.RequestChan &lt;- &amp;dispatcher.GetAdRequest{
                Request:      dispatcher.Request{RequestID: requestID},
                GetAdRequest: req,
        }

        select </span>{
        case resp := &lt;-a.dispatcher.ResponseChan.Load(requestID):<span class="cov8" title="1">
                if resp, ok := resp.(*dispatcher.GetAdResponse); ok </span><span class="cov8" title="1">{
                        return resp.Ads, resp.Total, resp.Err
                }</span>
        case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                return nil, 0, ErrTimeout</span>
        }

        <span class="cov0" title="0">return nil, 0, ErrUnknown</span>
}

func NewAdService(dispatcher *dispatcher.Dispatcher, db *gorm.DB, redis *redis.Client, locker *redislock.Client, asynqClient *asynq.Client) model.AdService <span class="cov8" title="1">{
        return &amp;AdService{
                dispatcher:  dispatcher,
                db:          db,
                redis:       redis,
                locker:      locker,
                lockKey:     "lock:ad",
                onShutdown:  make([]func(), 0),
                adStream:    "ad",
                asynqClient: asynqClient,
                shutdown:    atomic.Bool{},
                Version:     0,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "dcard-backend-2024/pkg/model"
        "encoding/json"

        "github.com/hibiken/asynq"
)

type TaskService struct {
        adService model.AdService
}

// HandleDeleteAd implements model.TaskService.
func (svc *TaskService) HandleDeleteAd(ctx context.Context, t *asynq.Task) error <span class="cov0" title="0">{
        var deletePayload model.AsynqDeletePayload
        if err := json.Unmarshal(t.Payload(), &amp;deletePayload); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return svc.adService.DeleteAd(ctx, deletePayload.AdID)</span>
}

func (svc *TaskService) RegisterTaskHandler(mux *asynq.ServeMux) <span class="cov0" title="0">{
        mux.HandleFunc(model.AsynqDeletePayload{}.TypeName(), svc.HandleDeleteAd)
}</span>

func NewTaskService(adService model.AdService) model.TaskService <span class="cov0" title="0">{
        return &amp;TaskService{
                adService: adService,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package syncmap

import "sync"

type Map struct {
        syncMap sync.Map
}

func (m *Map) LoadOrStore(key string, value chan interface{}) (chan interface{}, bool) <span class="cov0" title="0">{
        val, loaded := m.syncMap.LoadOrStore(key, value)
        return val.(chan interface{}), loaded
}</span>

func (m *Map) Load(key string) chan interface{} <span class="cov0" title="0">{
        val, ok := m.syncMap.Load(key)
        if ok </span><span class="cov0" title="0">{
                return val.(chan interface{})
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func (m *Map) Exists(key string) bool <span class="cov0" title="0">{
        _, ok := m.syncMap.Load(key)
        return ok
}</span>

func (m *Map) Store(key string, value chan interface{}) <span class="cov0" title="0">{
        m.syncMap.Store(key, value)
}</span>

func (m *Map) Delete(key string) <span class="cov0" title="0">{
        m.syncMap.Delete(key)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
